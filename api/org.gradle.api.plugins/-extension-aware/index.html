<HTML>
<HEAD>
<meta charset="UTF-8">
<title>ExtensionAware - api</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">api</a>&nbsp;/&nbsp;<a href="../index.html">org.gradle.api.plugins</a>&nbsp;/&nbsp;<a href=".">ExtensionAware</a><br/>
<br/>
<h1>ExtensionAware</h1>
<code><span class="keyword">interface </span><span class="identifier">ExtensionAware</span></code>
<p>Objects that can be extended at runtime with other objects. <pre><code> // Extensions are just plain objects, there is no interface/type class MyExtension { String foo MyExtension(String foo) { this.foo = foo } } // Add new extensions via the extension container project.extensions.create('custom', MyExtension, "bar") // («name», «type», «constructor args», …) // extensions appear as properties on the target object by the given name assert project.custom instanceof MyExtension assert project.custom.foo == "bar" // also via a namespace method project.custom { assert foo == "bar" foo = "other" } assert project.custom.foo == "other" // Extensions added with the extension container's create method are themselves extensible assert project.custom instanceof ExtensionAware project.custom.extensions.create("nested", MyExtension, "baz") assert project.custom.nested.foo == "baz" // All extension aware objects have a special “ext” extension of type ExtraPropertiesExtension assert project.hasProperty("myProperty") == false project.ext.myProperty = "myValue" // Properties added to the “ext” extension are promoted to the owning object assert project.myProperty == "myValue" </code></pre> Many Gradle objects are extension aware. This includes; projects, tasks, configurations, dependencies etc. 
<p> For more on adding &amp; creating extensions, see ExtensionContainer. </p>
<p> For more on extra properties, see ExtraPropertiesExtension. </p>
<p> An <code>ExtensionAware</code> object has several 'scopes' that Gradle searches for properties. These scopes are:</p>
 <ul> <li>The object itself. This scope includes any property getters and setters declared by the implementation class. The properties of this scope are readable or writable depending on the presence of the corresponding getter or setter method.</li>
 <li>Groovy Meta-programming methods implemented by the object's class, like <code>propertyMissing()</code>. Care must be taken by plugin authors to ensure <code>propertyMissing()</code> is implemented such that if a property is not found a MissingPropertyException(String, Class) exception is thrown. If <code>propertyMissing()</code> always returns a value for any property, <em>Gradle will not search the rest of the scopes below.</em></li>
 <li>The <em>extra</em> properties of the object. Each object maintains a map of extra properties, which can contain any arbitrary name -&gt; value pair. Once defined, the properties of this scope are readable and writable.</li>
 <li>The <em>extensions</em> added to the object by plugins. Each extension is available as a read-only property with the same name as the extension.</li>
 </ul>
</p>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="get-extensions.html">getExtensions</a></p>
</td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">fun </span><span class="identifier">getExtensions</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="../-extension-container/index.html"><span class="identifier">ExtensionContainer</span></a></code>
<p>The container of extensions.</p>
</td>
</tr>
</tbody>
</table>
<h3>Extension Properties</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="../../org.gradle.script.lang.kotlin/org.gradle.api.plugins.-extension-aware/extra.html">extra</a></p>
</td>
<td>
<code><span class="keyword">val </span><span class="identifier">ExtensionAware</span><span class="symbol">.</span><span class="identifier">extra</span><span class="symbol">: </span><a href="../-extra-properties-extension/index.html"><span class="identifier">ExtraPropertiesExtension</span></a></code>
<p>The extra properties extension in this object's extension container.</p>
</td>
</tr>
</tbody>
</table>
<h3>Inheritors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="../../org.gradle.api/-project/index.html">Project</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">Project</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html"><span class="identifier">Comparable</span></a><span class="symbol">&lt;</span><a href="../../org.gradle.api/-project/index.html"><span class="identifier">Project</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">ExtensionAware</span><span class="symbol">, </span><a href="../-plugin-aware/index.html"><span class="identifier">PluginAware</span></a></code>
<p>
<p>This interface is the main API you use to interact with Gradle from your build file. From a <code>Project</code>, you have programmatic access to all of Gradle's features.</p>
 Lifecycle 
<p>There is a one-to-one relationship between a <code>Project</code> and a <code>{@value #DEFAULT_BUILD_FILE}</code> file. During build initialisation, Gradle assembles a <code>Project</code> object for each project which is to participate in the build, as follows:</p>
 <ul> <li>Create a org.gradle.api.initialization.Settings instance for the build.</li>
 <li>Evaluate the <code>{@value org.gradle.api.initialization.Settings#DEFAULT_SETTINGS_FILE}</code> script, if present, against the org.gradle.api.initialization.Settings object to configure it.</li>
 <li>Use the configured org.gradle.api.initialization.Settings object to create the hierarchy of <code>Project</code> instances.</li>
 <li>Finally, evaluate each <code>Project</code> by executing its <code>{@value #DEFAULT_BUILD_FILE}</code> file, if present, against the project. The projects are evaluated in breadth-wise order, such that a project is evaluated before its child projects. This order can be overridden by calling <code><code><a href="../../org.gradle.api/-project/evaluation-depends-on-children.html">#evaluationDependsOnChildren()</a></code></code> or by adding an explicit evaluation dependency using <code><code><a href="#">#evaluationDependsOn(String)</a></code></code>.</li>
 </ul>
 Tasks 
<p>A project is essentially a collection of Task objects. Each task performs some basic piece of work, such as compiling classes, or running unit tests, or zipping up a WAR file. You add tasks to a project using one of the <code>create()</code> methods on TaskContainer, such as <code><a href="#">TaskContainer#create(String)</a></code>. You can locate existing tasks using one of the lookup methods on TaskContainer, such as <code><a href="#">org.gradle.api.tasks.TaskCollection#getByName(String)</a></code>.</p>
 Dependencies 
<p>A project generally has a number of dependencies it needs in order to do its work. Also, a project generally produces a number of artifacts, which other projects can use. Those dependencies are grouped in configurations, and can be retrieved and uploaded from repositories. You use the org.gradle.api.artifacts.ConfigurationContainer returned by <code><a href="../../org.gradle.api/-project/get-configurations.html">#getConfigurations()</a></code> method to manage the configurations. The returned by <code><a href="../../org.gradle.api/-project/get-dependencies.html">#getDependencies()</a></code> method to manage the dependencies. The org.gradle.api.artifacts.dsl.ArtifactHandler returned by <code><a href="../../org.gradle.api/-project/get-artifacts.html">#getArtifacts()</a></code> method to manage the artifacts. The org.gradle.api.artifacts.dsl.RepositoryHandler returned by <code><a href="../../org.gradle.api/-project/get-repositories.html"> </a></code> method to manage the repositories.</p>
 Multi-project Builds 
<p>Projects are arranged into a hierarchy of projects. A project has a name, and a fully qualified path which uniquely identifies it in the hierarchy.</p>
 Plugins 
<p> Plugins can be used to modularise and reuse project configuration. Plugins can be applied using the <code><a href="#">PluginAware#apply(java.util.Map)</a></code> method, or by using the org.gradle.plugin.use.PluginDependenciesSpec. </p>
 <a href="#"></a> Properties 
<p>Gradle executes the project's build file against the <code>Project</code> instance to configure the project. Any property or method which your script uses is delegated through to the associated <code>Project</code> object. This means, that you can use any of the methods and properties on the <code>Project</code> interface directly in your script. </p>
<p>For example: </p>
<pre><code> defaultTasks('some-task') // Delegates to Project.defaultTasks() reportsDir = file('reports') // Delegates to Project.file() and the Java Plugin </code></pre> 
<p>You can also access the <code>Project</code> instance using the <code>project</code> property. This can make the script clearer in some cases. For example, you could use <code>project.name</code> rather than <code>name</code> to access the project's name.</p>
 
<p>A project has 5 property 'scopes', which it searches for properties. You can access these properties by name in your build file, or by calling the project's <code><a href="#">#property(String)</a></code> method. The scopes are:</p>
 <ul> <li>The <code>Project</code> object itself. This scope includes any property getters and setters declared by the <code>Project</code> implementation class. For example, <code><a href="../../org.gradle.api/-project/get-root-project.html">#getRootProject()</a></code> is accessible as the <code>rootProject</code> property. The properties of this scope are readable or writable depending on the presence of the corresponding getter or setter method.</li>
 <li>The <em>extra</em> properties of the project. Each project maintains a map of extra properties, which can contain any arbitrary name -&gt; value pair. Once defined, the properties of this scope are readable and writable. See <a href="#">extra properties</a> for more details.</li>
 <li>The <em>extensions</em> added to the project by the plugins. Each extension is available as a read-only property with the same name as the extension.</li>
 <li>The <em>convention</em> properties added to the project by the plugins. A plugin can add properties and methods to a project through the project's Convention object. The properties of this scope may be readable or writable, depending on the convention objects.</li>
 <li>The tasks of the project. A task is accessible by using its name as a property name. The properties of this scope are read-only. For example, a task called <code>compile</code> is accessible as the <code>compile</code> property.</li>
 <li>The extra properties and convention properties inherited from the project's parent, recursively up to the root project. The properties of this scope are read-only.</li>
 </ul>
 
<p>When reading a property, the project searches the above scopes in order, and returns the value from the first scope it finds the property in. If not found, an exception is thrown. See <code><a href="#">#property(String)</a></code> for more details.</p>
 
<p>When writing a property, the project searches the above scopes in order, and sets the property in the first scope it finds the property in. If not found, an exception is thrown. See <code><a href="#">#setProperty(String, Object)</a></code> for more details.</p>
 <a href="#"></a> Extra Properties All extra properties must be defined through the "ext" namespace. Once an extra property has been defined, it is available directly on the owning object (in the below case the Project, Task, and sub-projects respectively) and can be read and updated. Only the initial declaration that needs to be done via the namespace. <pre><code> project.ext.prop1 = "foo" task doStuff { ext.prop2 = "bar" } subprojects { ext.${prop3} = false } </code></pre> Reading extra properties is done through the "ext" or through the owning object. <pre><code> ext.isSnapshot = version.endsWith("-SNAPSHOT") if (isSnapshot) { // do snapshot stuff } </code></pre> Dynamic Methods 
<p>A project has 5 method 'scopes', which it searches for methods:</p>
 <ul> <li>The <code>Project</code> object itself.</li>
 <li>The build file. The project searches for a matching method declared in the build file.</li>
 <li>The <em>extensions</em> added to the project by the plugins. Each extension is available as a method which takes a closure or org.gradle.api.Action as a parameter.</li>
 <li>The <em>convention</em> methods added to the project by the plugins. A plugin can add properties and method to a project through the project's Convention object.</li>
 <li>The tasks of the project. A method is added for each task, using the name of the task as the method name and taking a single closure or org.gradle.api.Action parameter. The method calls the <code><a href="#">Task#configure(groovy.lang.Closure)</a></code> method for the associated task with the provided closure. For example, if the project has a task called <code>compile</code>, then a method is added with the following signature: <code>void compile(Closure configureClosure)</code>.</li>
 <li>The methods of the parent project, recursively up to the root project.</li>
 <li>A property of the project whose value is a closure. The closure is treated as a method and called with the provided parameters. The property is located as described above.</li>
 </ul>
</p>
</td>
</tr>
<tr>
<td>
<p><a href="../../org.gradle.api/-task/index.html">Task</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">Task</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html"><span class="identifier">Comparable</span></a><span class="symbol">&lt;</span><a href="../../org.gradle.api/-task/index.html"><span class="identifier">Task</span></a><span class="symbol">&gt;</span><span class="symbol">, </span><span class="identifier">ExtensionAware</span></code>
<p>
<p>A <code>Task</code> represents a single atomic piece of work for a build, such as compiling classes or generating javadoc.</p>
 
<p>Each task belongs to a Project. You can use the various methods on to create and lookup task instances. For example, <code><a href="#"> </a></code> creates an empty task with the given name. You can also use the <code>task</code> keyword in your build file: </p>
 <pre><code> task myTask task myTask { configure closure } task myTask(type: SomeType) task myTask(type: SomeType) { configure closure } </code></pre> 
<p>Each task has a name, which can be used to refer to the task within its owning project, and a fully qualified path, which is unique across all tasks in all projects. The path is the concatenation of the owning project's path and the task's name. Path elements are separated using the {@value org.gradle.api.Project#PATH_SEPARATOR} character.</p>
 Task Actions 
<p>A <code>Task</code> is made up of a sequence of Action objects. When the task is executed, each of the actions is executed in turn, by calling <code><a href="#">Action#execute</a></code>. You can add actions to a task by calling <code><a href="#"> </a></code> or <code><a href="#">#doLast(Action)</a></code>.</p>
 
<p>Groovy closures can also be used to provide a task action. When the action is executed, the closure is called with the task as parameter. You can add action closures to a task by calling <code><a href="#">#doFirst(groovy.lang.Closure)</a></code> or <code><a href="#">#doLast(groovy.lang.Closure)</a></code>.</p>
 
<p>There are 2 special exceptions which a task action can throw to abort execution and continue without failing the build. A task action can abort execution of the action and continue to the next action of the task by throwing a org.gradle.api.tasks.StopActionException. A task action can abort execution of the task and continue to the next task by throwing a org.gradle.api.tasks.StopExecutionException. Using these exceptions allows you to have precondition actions which skip execution of the task, or part of the task, if not true.</p>
 <a href="#"></a>Task Dependencies and Task Ordering 
<p>A task may have dependencies on other tasks or might be scheduled to always run after another task. Gradle ensures that all task dependencies and ordering rules are honored when executing tasks, so that the task is executed after all of its dependencies and any "must run after" tasks have been executed.</p>
 
<p>Dependencies to a task are controlled using <code><a href="#">#dependsOn(Object...)</a></code> or <code><a href="#">#setDependsOn(Iterable)</a></code>, and <code><a href="#">#mustRunAfter(Object...)</a></code>, <code><a href="#">#setMustRunAfter(Iterable)</a></code>, <code><a href="#">#shouldRunAfter(Object...)</a></code> and <code><a href="#">#setShouldRunAfter(Iterable)</a></code> are used to specify ordering between tasks. You can use objects of any of the following types to specify dependencies and ordering:</p>
 <ul> <li>A <code>String</code>, <code>CharSequence</code> or <code>groovy.lang.GString</code> task path or name. A relative path is interpreted relative to the task's Project. This allows you to refer to tasks in other projects.</li>
 <li>A Task.</li>
 <li>A closure. The closure may take a <code>Task</code> as parameter. It may return any of the types listed here. Its return value is recursively converted to tasks. A <code>null</code> return value is treated as an empty collection.</li>
 <li>A TaskDependency object.</li>
 <li>A Buildable object.</li>
 <li>A <code>Iterable</code>, <code>Collection</code>, <code>Map</code> or array. May contain any of the types listed here. The elements of the iterable/collection/map/array are recursively converted to tasks.</li>
 <li>A <code>Callable</code>. The <code>call()</code> method may return any of the types listed here. Its return value is recursively converted to tasks. A <code>null</code> return value is treated as an empty collection.</li>
 </ul>
 Using a Task in a Build File <a href="#"></a> Dynamic Properties 
<p>A <code>Task</code> has 4 'scopes' for properties. You can access these properties by name from the build file or by calling the <code><a href="#">#property(String)</a></code> method. You can change the value of these properties by calling the <code><a href="#">#setProperty(String, Object)</a></code> method.</p>
 <ul> <li>The <code>Task</code> object itself. This includes any property getters and setters declared by the <code>Task</code> implementation class. The properties of this scope are readable or writable based on the presence of the corresponding getter and setter methods.</li>
 <li>The <em>extensions</em> added to the task by plugins. Each extension is available as a read-only property with the same name as the extension.</li>
 <li>The <em>convention</em> properties added to the task by plugins. A plugin can add properties and methods to a task through the task's Convention object. The properties of this scope may be readable or writable, depending on the convention objects.</li>
 <li>The <em>extra properties</em> of the task. Each task object maintains a map of additional properties. These are arbitrary name -&gt; value pairs which you can use to dynamically add properties to a task object. Once defined, the properties of this scope are readable and writable.</li>
 </ul>
 Dynamic Methods 
<p>A Plugin may add methods to a <code>Task</code> using its Convention object.</p>
 Parallel Execution 
<p> By default, tasks are not executed in parallel unless a task is waiting on asynchronous work and another task (which is not dependent) is ready to execute. Parallel execution can be enabled by the <code>--parallel</code> flag when the build is initiated. In parallel mode, the tasks of different projects (i.e. in a multi project build) are able to be executed in parallel.</p>
</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
