<HTML>
<HEAD>
<meta charset="UTF-8">
<title>org.gradle.api.artifacts.dsl - api</title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">api</a>&nbsp;/&nbsp;<a href=".">org.gradle.api.artifacts.dsl</a><br/>
<br/>
<h2>Package org.gradle.api.artifacts.dsl</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-artifact-handler/index.html">ArtifactHandler</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ArtifactHandler</span></code>
<p>This class is for defining artifacts to be published and adding them to configurations. Creating publish artifacts does not mean to create an archive. What is created is a domain object which represents a file to be published and information on how it should be published (e.g. the name). 
<p>To create an publish artifact and assign it to a configuration you can use the following syntax:</p>
 <code>&lt;configurationName&gt; &lt;artifact-notation&gt;, &lt;artifact-notation&gt; ...</code> or <code>&lt;configurationName&gt; &lt;artifact-notation&gt; { ... some code to configure the artifact }</code> 
<p>The notation can be one of the following types:</p>
 <ul> <li>org.gradle.api.tasks.bundling.AbstractArchiveTask. The information for publishing the artifact is extracted from the archive task (e.g. name, extension, ...). An archive artifact is represented using an instance of PublishArtifact.</li>
 <li>java.io.File. The information for publishing the artifact is extracted from the file name. You can tweak the resulting values by using a closure to configure the properties of the artifact instance. A file artifact is represented using an instance of org.gradle.api.artifacts.ConfigurablePublishArtifact </li>
 <li>java.util.Map. The map should contain a 'file' key. This is converted to an artifact as described above. You can also specify other properties of the artifact using entries in the map. </li>
 </ul>
 Examples 
<p>An example showing how to associate an archive task with a configuration via the artifact handler. This way the archive can be published or referred in other projects via the configuration. </p>
<pre><code> configurations { //declaring new configuration that will be used to associate with artifacts schema } task schemaJar(type: Jar) { //some imaginary task that creates a jar artifact with some schema } //associating the task that produces the artifact with the configuration artifacts { //configuration name and the task: schema schemaJar } </code></pre></p>
</td>
</tr>
<tr>
<td>
<p><a href="-component-metadata-handler/index.html">ComponentMetadataHandler</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ComponentMetadataHandler</span></code>
<p>Allows the build to provide rules that modify the metadata of depended-on software components. 
<p>Possible uses of component metadata rules are: </p>
<ul> <li>Setting the status and status scheme of a component, overriding the value specified in the component descriptor.</li>
 <li>Declaring whether or not a component is 'changing', thus impacting the cache behaviour of the component.</li>
 </ul>
 
<p> Example: </p>
<pre><code> dependencies { components { // Set the status and status scheme for every component belonging to a module in the group "org.foo" all { ComponentMetadataDetails details -&gt; if (details.id.group == "org.foo") { def version = details.id.version // assuming status is last part of version string details.status = version.substring(version.lastIndexOf("-") + 1) details.statusScheme = ["bronze", "silver", "gold", "platinum"] } } // Treat all components in the module "org.foo:bar" as changing withModule("org.foo:bar") { ComponentMetadataDetails details -&gt; details.changing = true } } } </code></pre></p>
</td>
</tr>
<tr>
<td>
<p><a href="-component-module-metadata-handler/index.html">ComponentModuleMetadataHandler</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ComponentModuleMetadataHandler</span></code>
<p>Allows to modify the metadata of depended-on software components. 
<p> Example: </p>
<pre><code> dependencies { modules { //Configuring component module metadata for the entire "google-collections" module, // declaring that legacy library was replaced with "guava". //This way, Gradle's conflict resolution can use this information and use "guava" // in case both libraries appear in the same dependency tree. module("com.google.collections:google-collections") { replacedBy("com.google.guava:guava") } } } </code></pre></p>
</td>
</tr>
<tr>
<td>
<p><a href="-dependency-handler/index.html">DependencyHandler</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">DependencyHandler</span></code>
<p>
<p>A <code>DependencyHandler</code> is used to declare dependencies. Dependencies are grouped into configurations (see org.gradle.api.artifacts.Configuration).</p>
 
<p>To declare a specific dependency for a configuration you can use the following syntax:</p>
 <pre><code> dependencies { <em>configurationName</em> <em>dependencyNotation1</em>, <em>dependencyNotation2</em>, ... } </code></pre> 
<p>Example shows a basic way of declaring dependencies. </p>
<pre><code> apply plugin: 'java' //so that we can use 'compile', 'testCompile' for dependencies dependencies { //for dependencies found in artifact repositories you can use //the group:name:version notation compile 'commons-lang:commons-lang:2.6' testCompile 'org.mockito:mockito:1.9.0-rc1' //map-style notation: compile group: 'com.google.code.guice', name: 'guice', version: '1.0' //declaring arbitrary files as dependencies compile files('hibernate.jar', 'libs/spring.jar') //putting all jars from 'libs' onto compile classpath compile fileTree('libs') } </code></pre> Advanced dependency configuration 
<p>To do some advanced configuration on a dependency when it is declared, you can additionally pass a configuration closure:</p>
 <pre><code> dependencies { <em>configurationName</em>(<em>dependencyNotation</em>){ <em>configStatement1</em> <em>configStatement2</em> } } </code></pre> Examples of advanced dependency declaration including: <ul> <li>Forcing certain dependency version in case of the conflict.</li>
 <li>Excluding certain dependencies by name, group or both. More details about per-dependency exclusions can be found in docs for <code><a href="#">org.gradle.api.artifacts.ModuleDependency#exclude(java.util.Map)</a></code>.</li>
 <li>Avoiding transitive dependencies for certain dependency.</li>
 </ul>
 <pre><code> apply plugin: 'java' //so that I can declare 'compile' dependencies dependencies { compile('org.hibernate:hibernate:3.1') { //in case of versions conflict '3.1' version of hibernate wins: force = true //excluding a particular transitive dependency: exclude module: 'cglib' //by artifact name exclude group: 'org.jmock' //by group exclude group: 'org.unwanted', module: 'iAmBuggy' //by both name and group //disabling all transitive dependencies of this dependency transitive = false } } </code></pre> More examples of advanced configuration, useful when dependency module has multiple artifacts: <ul> <li>Declaring dependency to a specific configuration of the module.</li>
 <li>Explicit specification of the artifact. See also <code><a href="#">org.gradle.api.artifacts.ModuleDependency#artifact(groovy.lang.Closure)</a></code>.</li>
 </ul>
 <pre><code> apply plugin: 'java' //so that I can declare 'compile' dependencies dependencies { //configuring dependency to specific configuration of the module compile configuration: 'someConf', group: 'org.someOrg', name: 'someModule', version: '1.0' //configuring dependency on 'someLib' module compile(group: 'org.myorg', name: 'someLib', version:'1.0') { //explicitly adding the dependency artifact: artifact { //useful when some artifact properties unconventional name = 'someArtifact' //artifact name different than module name extension = 'someExt' type = 'someType' classifier = 'someClassifier' } } } </code></pre> Dependency notations 
<p>There are several supported dependency notations. These are described below. For each dependency declared this way, a Dependency object is created. You can use this object to query or further configure the dependency.</p>
 
<p>You can also always add instances of org.gradle.api.artifacts.Dependency directly:</p>
 <code><em>configurationName</em> &lt;instance&gt;</code> External dependencies 
<p>There are two notations supported for declaring a dependency on an external module. One is a string notation formatted this way:</p>
 <code><em>configurationName</em> "<em>group</em>:<em>name</em>:<em>version</em>:<em>classifier</em>@<em>extension</em>"</code> 
<p>The other is a map notation:</p>
 <code><em>configurationName</em> group: <em>group</em>, name: <em>name</em>, version: <em>version</em>, classifier: <em>classifier</em>, ext: <em>extension</em></code> 
<p>In both notations, all properties, except name, are optional.</p>
 
<p>External dependencies are represented by a .</p>
 <pre><code> apply plugin: 'java' //so that we can use 'compile', 'testCompile' for dependencies dependencies { //for dependencies found in artifact repositories you can use //the string notation, e.g. group:name:version compile 'commons-lang:commons-lang:2.6' testCompile 'org.mockito:mockito:1.9.0-rc1' //map notation: compile group: 'com.google.code.guice', name: 'guice', version: '1.0' } </code></pre> Project dependencies 
<p>To add a project dependency, you use the following notation: </p>
<p><code><em>configurationName</em> project(':someProject')</code> </p>
<p>The notation <code>project(':projectA')</code> is similar to the syntax you use when configuring a projectA in a multi-module gradle project. </p>
<p>By default, when you declare dependency to projectA, you actually declare dependency to the 'default' configuration of the projectA. If you need to depend on a specific configuration of projectA, use map notation for projects: </p>
<p><code><em>configurationName</em> project(path: ':projectA', configuration: 'someOtherConfiguration')</code> </p>
<p>Project dependencies are represented using a org.gradle.api.artifacts.ProjectDependency. </p>
File dependencies 
<p>You can also add a dependency using a org.gradle.api.file.FileCollection:</p>
 <code><em>configurationName</em> files('a file')</code> <pre><code> apply plugin: 'java' //so that we can use 'compile', 'testCompile' for dependencies dependencies { //declaring arbitrary files as dependencies compile files('hibernate.jar', 'libs/spring.jar') //putting all jars from 'libs' onto compile classpath compile fileTree('libs') } </code></pre> 
<p>File dependencies are represented using a org.gradle.api.artifacts.SelfResolvingDependency.</p>
 Dependencies to other configurations 
<p>You can add a dependency using a org.gradle.api.artifacts.Configuration.</p>
 
<p>When the configuration is from the same project as the target configuration, the target configuration is changed to extend from the provided configuration.</p>
 
<p>When the configuration is from a different project, a project dependency is added.</p>
 Gradle distribution specific dependencies 
<p>It is possible to depend on certain Gradle APIs or libraries that Gradle ships with. It is particularly useful for Gradle plugin development. Example:</p>
 <pre><code> //Our Gradle plugin is written in groovy apply plugin: 'groovy' //now we can use the 'compile' configuration for declaring dependencies dependencies { //we will use the Groovy version that ships with Gradle: compile localGroovy() //our plugin requires Gradle API interfaces and classes to compile: compile gradleApi() //we will use the Gradle test-kit to test build logic: testCompile gradleTestKit() } </code></pre> Client module dependencies 
<p>To add a client module to a configuration you can use the notation:</p>
 <pre><code><em>configurationName</em> module(<em>moduleNotation</em>) { <em>module dependencies</em> } </code></pre> The module notation is the same as the dependency notations described above, except that the classifier property is not available. Client modules are represented using a org.gradle.api.artifacts.ClientModule.</p>
</td>
</tr>
<tr>
<td>
<p><a href="-repository-handler/index.html">RepositoryHandler</a></p>
</td>
<td>
<code><span class="keyword">interface </span><span class="identifier">RepositoryHandler</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../org.gradle.api.artifacts/-artifact-repository-container/index.html"><span class="identifier">ArtifactRepositoryContainer</span></a></code>
<p>A <code>RepositoryHandler</code> manages a set of repositories, allowing repositories to be defined and queried.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
